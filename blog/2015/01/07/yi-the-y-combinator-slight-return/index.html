
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>(译) The Y combinator (Slight Return) - 翼をください</title>
  <meta name="author" content="shellfly">

  
  <meta name="description" content="(译) The Y combinator (Slight Return) Jan 7th, 2015 8:52 pm 翻译 | Comments or: How to Succeed at Recursion Without Really Recursing Tiger got to hunt &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://shellfly.github.com/blog/2015/01/07/yi-the-y-combinator-slight-return/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="翼をください" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body >
  <header role="banner" id="sidebar">
    <ul id="menu">

  <li class="title">
    <h1 id="title"><a href="/">翼をください</a></h1>
  </li>




<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:shellfly.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>



  <li class="link">
    <a href="/blog/archives/">archives</a>
  </li>
  <li class="link">
    <a href="/about/">about</a>
  </li>


</ul>

  </header>
  <section id="main">
    <article class="post">
  <div class="sharing-box">
  
  
  
</div>

  
  <header>
    
      <h2 class="entry-title">(译) The Y combinator (Slight Return)</h2>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-01-07T20:52:02+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>8:52 pm</span></time>
		

<span class="categories">
  
    <a class='category' href='/blog/categories/fan-yi/'>翻译</a>
  
</span>


        
         | <a href="#disqus_thread">Comments</a>
        
      </p>
    
  </header>


<p>or:</p>

<p><u>How to Succeed at Recursion Without Really Recursing</u></p>

<pre><code>Tiger got to hunt,
Bird got to fly;
Lisper got to sit and wonder, (Y (Y Y))?

Tiger got to sleep,
Bird got to land;
Lisper got to tell himself he understand.

  — Kurt Vonnegut, modified by Darius Bacon
</code></pre>

<!--more-->


<h2>介绍</h2>

<p>自从最近写了一篇关于Y combinator的文章后，收到了很多有用的评论，所以我觉得很适合把它在扩展一下，写一篇更完整的出来。这篇文章会说的更深入，但是我希望也能更好理解。你不需要先读完前一篇文章在读这篇（实际上你最好没读过），我需要的唯一的背景知识就是一点点Scheme编程语言包括递归和first-class functions，文章中我也会提到。欢迎（再一次）评论。</p>

<h2>为什么学习 Y combinator</h2>

<p>在详细的说明Y combinator到底是什么之前，我想先指出，为什么你，作为一个程序员，应该花时间来学习它。说实话，并没有什么实际的理由让你一定要学习Y combinator。尽管它的确有一点实际的作用，而且大部分是对于计算机语言学家们。尽管如此，我还是觉得你值得花时间来了解一点Y combinator的东西，因为：</p>

<ol>
<li><p>它是编程中最美的想法之一，如果你稍微有一点对于编程的审美，你一定会被Y combinator打动。</p></li>
<li><p>它以一种非常质朴的方式展现了函数式编程的简单想法是多么惊人和强大。</p></li>
</ol>


<p>1959年，英国科学家C. P. Snow做了一场有名的讲座叫 <strong><a href="http://en.wikipedia.org/wiki/The_Two_Cultures">The Two Cultures</a></strong> ,在讲座中他哀叹当时很多头脑聪明教育良好的人却对科学一无所知。他用热力学第二定律的知识作为可以认知科学和无法认知科学两种人的分界线。我想我们同样可以用Y combinator的知识作为了解函数式编程（也就是说，掌握充分函数式编程的知识）和不了解函数式编程的程序员之间的分界线。有一些其他工具也可以代替Y combinator很好的工作（尤其是monads），但是Y combinator会完成的更漂亮。所以如果你渴望知道真正的Lambda本质，那就继续读下去。</p>

<p>顺便提一下，<a href="http://www.paulgraham.com/">Paul Graham</a>(Lisp黑客，Lisp书籍作家，随笔作家，现在也是一名企业家)显然把Y combinator看的更重，他用<a href="http://www.ycombinator.com/">Y combinator</a>来命名他的创业孵化器公司。Paul通过这些知识变的富有，也许有其他人也会，也许甚至就是你。</p>

<hr />


<h2>一个谜题</h2>

<h2>阶乘</h2>

<p>我们通过定义几个计算阶乘的函数来开始我们的Y combinator之旅，一个非负整数的阶乘就是从1一直乘到它自己，所以我们有：</p>

<p class="indent">factorial 1 = 1
factorial 2 = 2 * 1 = 2
factorial 3 = 3 * 2 * 1 = 6
factorial 4 = 4 * 3 * 2 *1 = 24
</p>


<p>等等。（我在这里写函数时没有用括号，所以 factorial 3 和通常写的factorial(3)是一个意思。就先听我的）随着n的增长，阶乘增长的很快，20的阶乘等于2432902008176640000。0的阶乘被定义成1，事实证明这对于实际使用阶乘的场合是个非常合适的定义（比如解决组合数学问题的时候）。</p>

<h2>递归定义阶乘函数</h2>

<p>在编程语言里用一些像<code>while</code>和<code>for</code>这种循环控制语句，就能很容易地写出计算阶乘的函数（比如C或者Java）。但是写一个递归函数来计算阶乘也很简单，因为阶乘的定义就是递归的：</p>

<p class="indent">factorial 0 = 1
factorial n = n * factorial (n - 1)
</p>


<p>第二行适用于所有非0的<code>n</code>，事实上在计算机语言<a href="http://www.haskell.org/">Haskell</a>里，这就是实际定义阶乘函数的方式。在我们要用的<a href="http://www.schemers.org/">Scheme</a>语言里，这个函数会被写成这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">factorial</span> <span class="nv">n</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="mi">1</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">factorial</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Scheme里所有东西都是用括号括起来的前缀表达式，所以像<code>(- n 1)</code>这种就表示一般在其他编程语言里写的<code>n - 1</code>。至于要这么写的原因超出了这篇文章要说的范围，就不细说了，但是要习惯这种写法并不难。</p>

<p>事实上，上面关于阶乘函数在Scheme里面的定义，可以写成下面这种更明确的方式:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">factorial</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="mi">1</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">factorial</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键字<code>lambda</code>只是简单的表示我们在定义的（就是lambda左边小括号和它对应的括号之间所有的东西）是一个函数。紧跟在<code>lambda</code>后面，括号中的是函数的<em>参数列表</em>，这里只有一个参数<code>n</code>.<em>函数体</em>跟在参数列表后面，这里由<code>(if (= n 0) 1 (* n (factorial (- n 1))))</code>组成。这种函数叫<em>匿名函数</em>。我们在这里给了匿名函数一个名字<code>factorial</code>，但这其实不是必须的，而且通常如果只是用一次的话，一般是不给名字的。在Scheme和其他一些语言里面，匿名函数也被叫做<em>lambda表达式</em>。有许多其他语言也允许你定义匿名函数，包括Python，Ruby，Javascript，Ocaml和Haskell（但是不幸的是，在C，C++和Java里不行）。下面的文章里我们会用到很多lambda表达式。</p>

<p>在Scheme里面，刚才给出的<code>factorial</code>定义和上一个定义其实是相同的，Scheme会在执行之前把第一个转换成第二个这种形式，所以Scheme里面所有的函数都是真正的lambda表达式。</p>

<p>注意这个函数体里有一个对<code>factorial</code>（我们正在定义中的函数） 的调用，这是它之所以是一个递归定义的原因。我会称这种在函数体里使用函数名的定义为<em>显式递归定义</em>。（你可能会好奇 &ldquo;隐式递归定义&#8221;会是什么样的,不过我不准备用这种表达方式，但是我脑子里想到的概念是通过一种非递归的方式生成的递归函数——继续读下去！）</p>

<p>为了便于讨论，我们假设我们用的Scheme版本没有像C和Java中的<code>for</code>和<code>while</code>循环语句（尽管实际上，真正的Scheme实现里是有这些结构的，只是用了不同的名字）所以为了定义像<code>factorial</code>这样的函数，我们只能使用递归。Scheme通常被用来作为教学语言的原因一部分也是因为这个，它强制学生递归的思考问题。</p>



</article>

  <section class="comments">
    <h2>Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


    <nav role="navigation" id="pagination">

</nav>
  </section>
  <!-- Octopress Love -->
<footer id="octopress_linkback">
  <a href="http://octopress.org/">
    <span class="unicode_square">
      <span class="unicode_circle">
        &nbsp;
      </span>
    </span>
    <span class="octopress">Powered by Octopress</span>
 </a>
 <span class="small">(<a href="/atom.xml">rss</a>)</span>
</footer>


  

<script type="text/javascript">
      var disqus_shortname = 'shellfly';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://shellfly.github.com/blog/2015/01/07/yi-the-y-combinator-slight-return/';
        var disqus_url = 'http://shellfly.github.com/blog/2015/01/07/yi-the-y-combinator-slight-return/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>










</body>
</html>
