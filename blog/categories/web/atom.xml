<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web | 伤风's blog]]></title>
  <link href="http://shellfly.github.com/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://shellfly.github.com/"/>
  <updated>2012-10-03T08:28:25+08:00</updated>
  <id>http://shellfly.github.com/</id>
  <author>
    <name><![CDATA[shellfly]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Django集成uploadify]]></title>
    <link href="http://shellfly.github.com/blog/2012/09/14/django-uploadify-integrate/"/>
    <updated>2012-09-14T09:10:00+08:00</updated>
    <id>http://shellfly.github.com/blog/2012/09/14/django-uploadify-integrate</id>
    <content type="html"><![CDATA[<p><strong>django 1.4 ;uploadify 3.1</strong></p>

<p>uploadify实现多文件上传很简单，一个js，一个css和一个swf就行了。不过要想在Django里使用flash上传文件，还得动点手脚才行。</p>

<p>问题就出<a href="http://www.uploadify.com/documentation/uploadify/using-sessions-with-uploadify/" target=_blank>在这</a>,使用flash无法传递cookies到服务端,
服务端程序也就无法验证上传者的身份，如果在视图函数(views)上加了<strong>@login_required</strong>,请求就会一直被重定向，然后uploadify得到的就是一堆http 302或者IO error.</p>

<p>上面的链接里已经指出了问题并给了解决方法，但那是针对php的，django要麻烦的多，当然有个不是办法的办法，就是不用@login_required，这样不需要验证就能上传文件了...</p>

<p>既然没有cookies，那就需要手动添加cookies，Django的middleware正好适合干这事，uploaidfy的初始化选项里有个<strong>formData</strong>可以用来post数据，把要设置的cookies值，放在这里，
然后自定义一个middleware在<strong>process_requrest()</strong>里构造自己需要的cookies。</p>

<p>   一个小问题:django 1.4里的session cookies默认都有httponly选项，无法用js脚本获得这个值,还需要一个可以获得的sessionid</p>

<!-- more -->


<p>总结一下:</p>

<ol>
<li><p>在视图函数里手动建立一个没有httponly选项的sessionid，值和浏览器里的<strong>sessionid</strong>一样</p></li>
<li><p>在uploadify初始化里传递必要的参数</p></li>
<li><p>自定义一个middleware，在其中构造需要的cookies,自定义的middleware要放在settings.py里SessionMiddleware的前面</p></li>
</ol>


<p><code>python views.py
upload_sessionid=request.COOKIES['sessionid']
...
response.set_cookie('upload_sessionid',upload_sessionid,httponly=False)
return response
</code></p>

<p>```javascript main.js
$(function() {
   $('#file_upload').uploadify({</p>

<pre><code>    'swf'      : '/static/uploadify/uploadify.swf',
    'uploader' : '', // 设置为空，则为当前url
    // Put your options here
    'fileTypeExts':'*.jpg;*.bmp;*.png',
    'formData':{'upload_sessionid':$.cookie('upload_sessionid'),'selected_album':$('.selected_data').val()},
    'multi':true,
    'auto':true,
    'buttonText':'添加照片',
    'height':21,
    'width':81,
});
</code></pre>

<p>});
```</p>

<p>```python middleware.py
 from django.conf import settings</p>

<p> class UploadifyMiddleware(object):</p>

<pre><code>def process_request(self,request):
    if request.method == 'POST' and request.POST.has_key('upload_sessionid'):
        request.COOKIES[settings.SESSION_COOKIE_NAME] = request.POST['upload_sessionid']
</code></pre>

<p>```</p>

<p>```python settings.py
MIDDLEWARE_CLASSES = (</p>

<pre><code>'django.middleware.common.CommonMiddleware',
'albums.middleware.UploadifyMiddleware',
'django.contrib.sessions.middleware.SessionMiddleware',
...
</code></pre>

<p>```</p>

<p>这样应该就没问题了，不过视图函数还是要加上<strong>@csrf_exempt</strong>不然会出现403错误，我试着用同样的方法设置了csrftoken的cookies，不过貌似不起什么作用，先这样用着了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django自定义gravatar头像大小]]></title>
    <link href="http://shellfly.github.com/blog/2012/09/12/django-gravatar-resize/"/>
    <updated>2012-09-12T23:51:00+08:00</updated>
    <id>http://shellfly.github.com/blog/2012/09/12/django-gravatar-resize</id>
    <content type="html"><![CDATA[<p>Django可以很方便的集成gravatar，官方教程<a href="https://en.gravatar.com/site/implement/images/django/" target="_blank">在这</a>
就是自定义一个<strong>template tag</strong>，在模板里加载使用就行了。</p>

<p>给的代码是只有一个默认尺寸，把代码稍微改了以下，可以添加一个尺寸参数，如果没有提供第三个参数，默认是32.</p>

<p>``` python</p>

<pre><code>from django import template
import urllib, hashlib

register = template.Library()

class GravatarUrlNode(template.Node):
    def __init__(self, email, size=32):
        self.email = template.Variable(email)
        self.size = size
    def render(self, context):
        try:
            email = self.email.resolve(context)
        except template.VariableDoesNotExist:
            return ''

        #default = "http://www.gravatar.com/avatar/00000000000000000000000000000000?d=mm&amp;s=%s" % self.size

        gravatar_url = "http://www.gravatar.com/avatar/" + hashlib.md5(email.lower()).hexdigest() + "?"
        gravatar_url += urllib.urlencode({'d':'mm', 's':str(self.size)})

        return gravatar_url

@register.tag
def gravatar_url(parser, token):
    try:
        tag_name, email ,size = token.split_contents()
    except ValueError:
        try:
            tag_name,email = token.split_contents()
        except ValueError:
            raise template.TemplateSyntaxError, "useage:%r email [size]" % token.contents.split()[0]
        return GravatarUrlNode(email)

    return GravatarUrlNode(email,size) 
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript 闭包中的变量]]></title>
    <link href="http://shellfly.github.com/blog/2012/08/09/about-javascript-closure/"/>
    <updated>2012-08-09T14:59:00+08:00</updated>
    <id>http://shellfly.github.com/blog/2012/08/09/about-javascript-closure</id>
    <content type="html"><![CDATA[<p>闭包，简单点说就是一个function加上一个environment，这个environment中不仅包
含了function的局部变量，也包含了外部变量，这样看来所有的javascript函数都是一
个闭包。有趣的地方就在于当用到嵌套函数时，这些environment中外部变量有些特殊，他们包含上层函数的局部变量。</p>

<p>在练习一个书上的例子时遇到了一个问题，这个问题之前在看《python学习手册》
的时候也碰到过，当时没想明白，不过这次明白了。</p>

<p><strong>一个闭包environment中的外部变量是引用而不是拷贝</strong>，例如当声明一个嵌
套函数时，有个外部变量a=1,当这个嵌套函数实际被调用时，a可能已经变成了2;</p>

<p>下面就是最近做练习写的函数,遍历网页中的超链接，如果class==popup，就给
onclick事件放置一个处理函数。</p>

<!--more-->


<p>``` js</p>

<p>function popUp(url) {</p>

<pre><code>window.open(url,"doubanclaime07dd62c1ee49ef3","width=160,height=160");
</code></pre>

<p>  }</p>

<p>function preparelinks() {
   var links = document.getElementsByTagName("a");</p>

<pre><code>for (var i=0;i &lt;links.length; i++) {
    if (links[i].getAttribute("class") == "popup") {
        links[i].onclick = function() {
            popUp(links[i].getAttribute("href"));
            return false;
        }
    }
}
</code></pre>

<p>}</p>

<p>```
看样子好像没什么问题，但是并不能达到需要的效果，用浏览器调试可议发现
getAttribute是undefined的，问题就在于嵌套函数使用了<strong>变量i</strong>，如果在嵌套函
数中加一句<strong>alert(i)</strong> 就会发现，函数执行时i总是等于links的总长度，因
为闭包中包含的是外部变量的引用，在循环中i最后已经变成了length（数组从
下标0开始，lenght已经越界了），在onclick触发函数时，links[i]就是未定义
的。</p>

<p>这个问题有2个解决办法，一个是使用一个单独的变量保存for循环时的
links[i],然后在嵌套函数中使用这个变量。或者在嵌套函数中不使用links数组，
直接使用this关键字就能解决。</p>

<p><code>
   popUp(this.getAttribute("href"));  
</code></p>

<p>上面说道《python学习手册》也是我的python入门书，那时候看到函数那章,很
多高级用法平时都用不到，所以也没注意，这次倒是弄明白了一点。也是一个类
似的例子，在循环中创建闭包,记得那里好像叫做工厂函数
```python
def makefunc():</p>

<pre><code>funcs = []

for i in range(3):
    funcs.append(lambda x:x*i)

return funcs
</code></pre>

<p>funcs = makefunc()</p>

<h1>下面3个函数调用都返回4 而不是0 2 4</h1>

<p>funcs<a href="2">0</a>
funcs<a href="2">1</a>
funcs<a href="2">2</a></p>

<p><code>
python中提供的解决办法也是使用一个变量记录i的值，这样就不用和其他闭包
共享同一个i，
</code></p>

<pre><code>funcs.append(lambda x,i=i:x*i)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
